// Do not edit this file! Generated by Ragel.
// Ragel.exe -G2 -J -o JsonReader.java JsonReader.rl
/*******************************************************************************
 * Copyright (c) 2011, Nathan Sweet <nathan.sweet@gmail.com>
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <organization> nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

package com.esotericsoftware.jsonbeans;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.HashMap;

import com.esotericsoftware.jsonbeans.dom.JsonArray;
import com.esotericsoftware.jsonbeans.dom.JsonMap;
import com.esotericsoftware.jsonbeans.dom.JsonObject;
import com.esotericsoftware.jsonbeans.dom.JsonValue;

/** Lightweight JSON parser.<br>
 * <br>
 * The default behavior is to parse the JSON into a DOM made up of {@link JsonMap}, {@link JsonArray}, and {@link JsonValue}
 * objects. Extend this class and override methods to perform event driven parsing. When this is done, the parse methods will
 * return null.
 * @author Nathan Sweet */
public class JsonReader {
	public JsonObject parse (String json) {
		char[] data = json.toCharArray();
		return parse(data, 0, data.length);
	}

	public JsonObject parse (Reader reader) {
		try {
			char[] data = new char[1024];
			int offset = 0;
			while (true) {
				int length = reader.read(data, offset, data.length - offset);
				if (length == -1) break;
				if (length == 0) {
					char[] newData = new char[data.length * 2];
					System.arraycopy(data, 0, newData, 0, data.length);
					data = newData;
				} else
					offset += length;
			}
			return parse(data, 0, offset);
		} catch (IOException ex) {
			throw new SerializationException(ex);
		}
	}

	public JsonObject parse (InputStream input) {
		try {
			return parse(new InputStreamReader(input, "ISO-8859-1"));
		} catch (IOException ex) {
			throw new SerializationException(ex);
		}
	}

	public JsonObject parse (File file) {
		try {
			return parse(new FileInputStream(file));
		} catch (Exception ex) {
			throw new SerializationException("Error parsing file: " + file, ex);
		}
	}

	public JsonObject parse (char[] data, int offset, int length) {
		int cs, p = offset, pe = length, eof = pe, top = 0;
		int[] stack = new int[4];

		int s = 0;
		ArrayList<String> names = new ArrayList(8);
		boolean needsUnescape = false;
		RuntimeException parseRuntimeEx = null;

		boolean debug = false;
		if (debug) System.out.println();

		try {
		%%{
			machine json;

			prepush {
				if (top == stack.length) {
					int[] newStack = new int[stack.length * 2];
					System.arraycopy(stack, 0, newStack, 0, stack.length);
					stack = newStack;
				}
			}

			action buffer {
				s = p;
				needsUnescape = false;
			}
			action needsUnescape {
				needsUnescape = true;
			}
			action name {
				String name = new String(data, s, p - s);
				s = p;
				if (needsUnescape) name = unescape(name);
				if (debug) System.out.println("name: " + name);
				names.add(name);
			}
			action string {
				String value = new String(data, s, p - s);
				s = p;
				if (needsUnescape) value = unescape(value);
				String name = names.isEmpty() ? null : names.remove(names.size() - 1);
				if (debug) System.out.println("string: " + name + "=" + value);
				string(name, value);
			}
			action number {
				String value = new String(data, s, p - s);
				s = p;
				String name = names.isEmpty() ? null : names.remove(names.size() - 1);
				if (debug) System.out.println("number: " + name + "=" + Float.parseFloat(value));
				number(name, Float.parseFloat(value));
			}
			action trueValue {
				String name = names.isEmpty() ? null : names.remove(names.size() - 1);
				if (debug) System.out.println("boolean: " + name + "=true");
				bool(name, true);
			}
			action falseValue {
				String name = names.isEmpty() ? null : names.remove(names.size() - 1);
				if (debug) System.out.println("boolean: " + name + "=false");
				bool(name, false);
			}
			action null {
				String name = names.isEmpty() ? null : names.remove(names.size() - 1);
				if (debug) System.out.println("null: " + name);
				string(name, null);
			}
			action startObject {
				String name = names.isEmpty() ? null : names.remove(names.size() - 1);
				if (debug) System.out.println("startObject: " + name);
				startObject(name);
				fcall object;
			}
			action endObject {
				if (debug) System.out.println("endObject");
				pop();
				fret;
			}
			action startArray {
				String name = names.isEmpty() ? null : names.remove(names.size() - 1);
				if (debug) System.out.println("startArray: " + name);
				startArray(name);
				fcall array;
			}
			action endArray {
				if (debug) System.out.println("endArray");
				pop();
				fret;
			}

			# parse single quote
			quotedChars = (^["\\] | ('\\' ["\\/bfnrtu] >needsUnescape))*;
			unquotedChars = [a-zA-Z_$] ^([:}\],] | space)*;
			name = ('"' quotedChars >buffer %name '"') | unquotedChars >buffer %name;

			startObject = '{' @startObject;
			startArray = '[' @startArray;
			string = '"' quotedChars >buffer %string '"';
			unquotedString = unquotedChars >buffer %string;
			number = ('-'? ('0' | ([1-9][0-9]*)) ('.' [0-9]+)? ([eE] [+\-]? [0-9]+)?) >buffer %number;
			nullValue = 'null' %null;
			booleanValue = 'true' %trueValue | 'false' %falseValue;
			value = startObject | startArray | number | string @2 | nullValue @2 | booleanValue @2 | unquotedString @-1;

			nameValue = name space* ':' space* value;

			object := space* (nameValue space*)? (',' space* nameValue space*)** ','? space* '}' @endObject;

			array := space* (value space*)? (',' space* value space*)** ','? space* ']' @endArray;

			main := space* value space*;

			write init;
			write exec;
		}%%
		} catch (RuntimeException ex) {
			parseRuntimeEx = ex;
		}

		if (p < pe) {
			int lineNumber = 1;
			for (int i = 0; i < p; i++)
				if (data[i] == '\n') lineNumber++;
			throw new SerializationException("Error parsing JSON on line " + lineNumber + " near: " + new String(data, p, pe - p),
				parseRuntimeEx);
		} else if (!elements.isEmpty()) {
			Object element = elements.get(elements.size() - 1);
			elements.clear();
			if (element instanceof HashMap)
				throw new SerializationException("Error parsing JSON, unmatched brace.");
			else
				throw new SerializationException("Error parsing JSON, unmatched bracket.");
		}
		JsonObject root = this.root;
		this.root = null;
		return root;
	}

	%% write data;

	private final ArrayList<JsonObject> elements = new ArrayList(8);
	private JsonObject root, current;

	private void set (String name, JsonObject value) {
		if (current instanceof JsonMap)
			((JsonMap)current).put(name, value);
		else if (current instanceof JsonArray)
			((JsonArray)current).add(value);
		else
			root = value;
	}

	protected void startObject (String name) {
		JsonMap value = new JsonMap();
		if (current != null) set(name, value);
		elements.add(value);
		current = value;
	}

	protected void startArray (String name) {
		JsonArray value = new JsonArray();
		if (current != null) set(name, value);
		elements.add(value);
		current = value;
	}

	protected void pop () {
		int lastIndex = elements.size() - 1;
		root = elements.remove(lastIndex);
		current = lastIndex > 0 ? elements.get(lastIndex - 1) : null;
	}

	protected void string (String name, String value) {
		set(name, value == null ? null : new JsonValue(value));
	}

	protected void number (String name, float value) {
		set(name, new JsonValue(value));
	}

	protected void bool (String name, boolean value) {
		set(name, new JsonValue(value));
	}

	private String unescape (String value) {
		int length = value.length();
		StringBuilder buffer = new StringBuilder(length + 16);
		for (int i = 0; i < length;) {
			char c = value.charAt(i++);
			if (c != '\\') {
				buffer.append(c);
				continue;
			}
			if (i == length) break;
			c = value.charAt(i++);
			if (c == 'u') {
				buffer.append(Character.toChars(Integer.parseInt(value.substring(i, i + 4), 16)));
				i += 4;
				continue;
			}
			switch (c) {
			case '"':
			case '\\':
			case '/':
				break;
			case 'b':
				c = '\b';
				break;
			case 'f':
				c = '\f';
				break;
			case 'n':
				c = '\n';
				break;
			case 'r':
				c = '\r';
				break;
			case 't':
				c = '\t';
				break;
			default:
				throw new SerializationException("Illegal escaped character: \\" + c);
			}
			buffer.append(c);
		}
		return buffer.toString();
	}
}
